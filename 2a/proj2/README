1. DONE

2. DONE

3. 
From the language specification, create a grammar which accepts all valid programs for our language. 
This is the crucial part. 

4. Implement the scanner (in Lex) and make sure you account for all of the lexical patterns. Ensure that your scanner gives an error for dangling comments (comments not terminated before the EOF is reached), and make sure that it handles characters and strings correctly.

5. Implement your grammar (in Yacc). Save time for this part, since you will likely have to iteratively correct for errors.

6. TEST: You can find some test files here. You will want to test your parser using these good and bad files thoroughly. You must also create your own test files. Make them as complete and complex as possible. To test your Lexer, put printf statements before you return something. This will tell you where your scanner stopped working AND which token you just failed in parsing. To test your Parser, put printf statements after each rule. This will make it easier for you to trace what your parser is doing. To run your program use:

./simple < test.lang

where test.lang is a test file. If you run Yacc with the -v flag, it will write the file y.output. It contains a readable description of the parsing tables (more specifically, a description of the LR(1) states and the items they contain). In addition, it will report where the conflicts or problems in the grammar appear. Make sure you get the Lexer working perfectly first! Lex allows you to execute C code when it matches a rule (AFTER it matches the rule). Simply print to stdout like you did for the previous project. You should get a stream of tokens.



1. Your parser should be able parse any valid input file from our language.

2. You will need to catch ALL syntax errors.

3. You will need to catch ALL program structure errors. By this I mean that your parser has to know that the keyword "function" ALWAYS precedes a return type in a function declaration.

4. You will need to make sure the Return statement can only be placed at the very end of a function block. The Return statement NOT like any other statement.

5. You will NOT have to check that function and variables have been declared before you use them.

6. You will NOT have to check that there is one and only one Main(). Remember that Main() is just a special function. At this point we don't care that it is special. No functions at all would be an acceptible input.

7. You will NOT have to check that function_ids and variable_ids are used multiple times. So you could declare variable A multiple times and it would be okay at this point.

8. You will NOT have to check the return types of functions. You will NOT have to check the types used in variable assignments. You will NOT have to check the type of expressions in If and While statements.

9. In a nutshell, your parser looks at each line of code individually. It does not have global knowledge of variables or functions....yet.

10. If you successfully parse the input, your parser shouldn't print out anything to the output. Otherwise, throw an error message using yyerror as defined in the sample parser.ypp file.

11. If some parts of the specs are not clear, send an email to cs160-w13-ucsb@googlegroups.com and we'll resolve the issue as soon as possible and update these specs.