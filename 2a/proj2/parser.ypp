%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <iostream>
	#define YYDEBUG 1

	int yylex(void);
	void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

/* WRITE ME: put all your token definitions here*/
/* WRITE ME: put all your type definitions here*/
/* WRITE ME: put all your precedence/associativity rules here*/

/*
NOTE:
digits in upper level
everything exept aritmetic operators will be not be left?

highest presidenve unary?
*/

%start ROOT

%token BOOL
%token ELSE
%token IF
%token INT
%token WHILE
%token VAR
%token FUNCTION
%token INTARRAY
%token RETURN

%token EQT
%token GT
%token GE
%token LT
%token LE
%token NE
%token AND
%token OR
%token NOT
%token PLUS
%token MINUS
%token MULT
%token DIVIDE

%token TRUE
%token FALSE
%token DECIMAL
%token HEX
%token OCTAL
%token BINARY
%token IDENTIFIER

%token SEMICOLON
%token COMMA
%token ABS
%token SC
%token EC
%token RPAREN
%token LPAREN
%token BAI
%token EAI
%token EQ

%%

/* WRITE ME: This is the language from Project 1(Calculator). You need
			 to put the productions for the grammar for the
			 language for this project here*/

ROOT        : funcsq funcsq { }
            | funcsq
            ;

funcsq      : FUNCTION type IDENTIFIER LPAREN parm_list RPAREN SC body_func EC 
            ;

parm_list   : type IDENTIFIER parm_list
            | COMMA type IDENTIFIER parm_list
            | /* */
            ;

type        : INT
            | BOOL
            | INTARRAY BAI exprS EAI
            ;

body_func	: var_dec body_func
            | funcsq body_func
            | state body_func
            |
            ;

var_dec     : VAR type IDENTIFIER var_decC SEMICOLON
            ;

var_decC    : COMMA IDENTIFIER var_decC
            |
            ;

state       : IDENTIFIER EQ exprS SEMICOLON
            | IDENTIFIER EQ IDENTIFIER LPAREN IDENTIFIER RPAREN SEMICOLON
            | IDENTIFIER BAI exprS EAI EQ exprS SEMICOLON
            | IDENTIFIER LPAREN RPAREN SEMICOLON
            | IDENTIFIER EQ IDENTIFIER LPAREN exprS COMMA exprS RPAREN SEMICOLON
            | ifstmt
            | return_stat
            ;

return_stat : RETURN exprS SEMICOLON
            ;

ifstmt      : IF LPAREN exprS RPAREN SC state EC ifrest
            ;

ifrest      : ELSE SC state EC
            | 
            ;


exprS       : exprS relexpr
            | relexpr
            ;


relexpr     : relexpr LT expr
            | relexpr GT expr
            | relexpr EQ expr
            | expr
            ;

expr        : expr PLUS term    { $$ = $1 + $3; }
            | expr MINUS term   { $$ = $1 - $3; }
            | term
            ;

term        : term MULT unary    { $$ = $1 * $3; }
            | term DIVIDE unary  {   if($3 == 0.0)
                                        yyerror("divide by zero");
                                    else
                                        $$ = $1 / $3;
                                }
            | unary 
            ;

unary       : fact
            | MINUS fact
            ;

fact        : IDENTIFIER
            | integer
            | boolean
            ;

integer     : DECIMAL
            | OCTAL
            ;

boolean     : TRUE
            | FALSE
            ;

%%

/*

*/


/*You shouldn't have to do anything past this*/

extern int yylineno;

void yyerror(const char *s) {
	fprintf(stderr, "%s at line %d\n", s, yylineno);
	exit(0);
}
